{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 0. 问题简介及背景知识"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 问题简介"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "这个项目中我们会利用生成式模型来进行单文档自动摘要，并在**DUC 2004 dataset**上进行模型最终效果的测试。评价指标是ROUGE。最后我们在**DUC2004 TASK 1**应该得到的结果如下："
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "```\n",
    "[KEY: > input(description), = target(headline), < output]\n",
    "\n",
    "> a south korean lawmaker said friday communist north korea could be producing plutonium and could have more secret underground nuclear facilities than already feared .\n",
    "= s . korea says n . korea could be producing plutonium in underground plants .\n",
    "< n korea korea korea n . korea korea korea producing plutonium . <EOS>\n",
    "\n",
    "> egyptian president hosni mubarak met here sunday with syrian president hafez assad to try to defuse growing tension between syria and turkey .\n",
    "= egypt s mubarak attempts mediation of turkey syria dispute\n",
    "< egypt s mubarak attempts mediation of turkey syria dispute <EOS>\n",
    "\n",
    "> police and soldiers on friday blocked off the street in front of a house where members of a terrorist gang are believed to have assembled the bomb that blew up the u .s . embassy killing people .\n",
    "= suspects in us embassy bombings arrested in dar es salaam and new york\n",
    "< nobel police american in operative business thai to to to to . <EOS>\n",
    "\n",
    "> premier romano prodi battled tuesday for any votes freed up from a split in a far left party but said he will resign if he loses a confidence vote expected later this week .\n",
    "= prodi faces confidence vote break with prodi divides refounding party .\n",
    "< ecevit confidence confidence vote with business divides be be be . . <EOS>\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "其中`>`为文本输入，`=`为headline，`<`为我们模型的预计输出"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "我们的模型共分两部分，本篇主要是生成式模型，借鉴了[sequence to sequence network](http://arxiv.org/abs/1409.3215)，seq2seq模型利用两个RNN网络来实现将一个序列转化为另一个序列，其中Encoder网络将输入序列映射为一个向量，Decoder网络将该向量展开为一个新的序列。\n",
    "\n",
    "在此基础上，我们还引入了[attention 机制](https://arxiv.org/abs/1409.0473)，他可以让decoder专注于输入序列的特定部分，提升模型的效果。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 背景知识"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Seq2Seq模型，The Sequence to Sequence model\n",
    "\n",
    "A [Sequence to Sequence network](http://arxiv.org/abs/1409.3215), or seq2seq network, or [Encoder Decoder network](https://arxiv.org/pdf/1406.1078v3.pdf), is a model consisting of two separate RNNs called the **encoder** and **decoder**. The encoder reads an input sequence one item at a time, and outputs a vector at each step. The final output of the encoder is kept as the **context** vector. The decoder uses this context vector to produce a sequence of outputs one step at a time.\n",
    "\n",
    "![](https://i.imgur.com/tVtHhNp.png)\n",
    "\n",
    "When using a single RNN, there is a one-to-one relationship between inputs and outputs. We would quickly run into problems with different sequence orders and lengths that are common during translation. Consider the simple sentence \"Je ne suis pas le chat noir\" &rarr; \"I am not the black cat\". Many of the words have a pretty direct translation, like \"chat\" &rarr; \"cat\". However the differing grammars cause words to be in different orders, e.g. \"chat noir\" and \"black cat\". There is also the \"ne ... pas\" &rarr; \"not\" construction that makes the two sentences have different lengths.\n",
    "\n",
    "With the seq2seq model, by encoding many inputs into one vector, and decoding from one vector into many outputs, we are freed from the constraints of sequence order and length. The encoded sequence is represented by a single vector, a single point in some N dimensional space of sequences. In an ideal case, this point can be considered the \"meaning\" of the sequence.\n",
    "\n",
    "This idea can be extended beyond sequences. Image captioning tasks take an [image as input, and output a description](https://arxiv.org/abs/1411.4555) of the image (img2seq). Some image generation tasks take a [description as input and output a generated image](https://arxiv.org/abs/1511.02793) (seq2img). These models can be referred to more generally as \"encoder decoder\" networks."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 注意力机制，The Attention Mechanism\n",
    "\n",
    "The fixed-length vector carries the burden of encoding the the entire \"meaning\" of the input sequence, no matter how long that may be. With all the variance in language, this is a very hard problem. Imagine two nearly identical sentences, twenty words long, with only one word different. Both the encoders and decoders must be nuanced enough to represent that change as a very slightly different point in space.\n",
    "\n",
    "The **attention mechanism** [introduced by Bahdanau et al.](https://arxiv.org/abs/1409.0473) addresses this by giving the decoder a way to \"pay attention\" to parts of the input, rather than relying on a single vector. For every step the decoder can select a different part of the input sentence to consider.\n",
    "\n",
    "![](https://i.imgur.com/5y6SCvU.png)\n",
    "\n",
    "Attention is calculated with another feedforward layer in the decoder. This layer will use the current input and hidden state to create a new vector, which is the same size as the input sequence (in practice, a fixed maximum length). This vector is processed through softmax to create *attention weights*, which are multiplied by the encoders' outputs to create a new context vector, which is then used to predict the next output.\n",
    "\n",
    "![](https://i.imgur.com/K1qMPxs.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. 环境配置"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " #### 使用PyTorch设计网络"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import unicodedata\n",
    "import string\n",
    "import re\n",
    "import random\n",
    "import time\n",
    "import math\n",
    "\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "from torch.autograd import Variable\n",
    "from torch import optim\n",
    "import torch.nn.functional as F"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 使用NVIDIA 1080ti + CUDA 加速训练"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "USE_CUDA = True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. 获取及整理数据集"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "本次任务是在 DUC2004 Task1 上进行单文档摘要提取，由于生成摘要模型部分需要的训练数据较多，因此我们需要利用外部的同源数据集进行训练。这里我们利用`Gigaword`数据集进行训练，从OpenNMT的论坛上[1]可以下载到预处理后的文本，下载解压后我们把数据整理为如下格式：`/train/train.article.txt`  和 `/train/train.title.txt`。 `train.article.txt`每行都是一个新闻(news)，行之间以`\\n`分隔，`train.title.txt`中是对应的摘要(title)。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "## 训练数据所在位置，注意最后没有文件分隔符'/'\n",
    "file_path = '/root/sharefolder/data/text_mining/sumdata/train'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 建立词表，word indexing"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "我们需要获取每个单词的index，便于输入网络。因此建立一个`Voc`类，包含几个词典 : `word2index`，`word2count`，`index2word`。其中`word2index`是获取每个单词的index，`index2word`是根据index获取对应的单词，`word2count`是用来记录各个单词的词频，用于后续的低频词筛选。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "SOS_token = 0\n",
    "EOS_token = 1\n",
    "\n",
    "class Voc:\n",
    "    def __init__(self, name):\n",
    "        self.name = name\n",
    "        self.word2index = {}\n",
    "        self.word2count = {}\n",
    "        self.index2word = {0: \"SOS\", 1: \"EOS\"}\n",
    "        self.n_words = 2 # Count SOS and EOS\n",
    "      \n",
    "    def index_words(self, sentence):\n",
    "        for word in sentence.split(' '):\n",
    "            self.index_word(word)\n",
    "\n",
    "    def index_word(self, word):\n",
    "        if word not in self.word2index:\n",
    "            self.word2index[word] = self.n_words\n",
    "            self.word2count[word] = 1\n",
    "            self.index2word[self.n_words] = word\n",
    "            self.n_words += 1\n",
    "        else:\n",
    "            self.word2count[word] += 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 读取数据，Reading and decoding files"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "数据是以`Unicode`存储的，为了简化我们进行一些预处理，包括：转化为ASCII编码、小写化、去掉部分标点符号等"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# Turn a Unicode string to plain ASCII, thanks to http://stackoverflow.com/a/518232/2809427\n",
    "def unicode_to_ascii(s):\n",
    "    return ''.join(\n",
    "        c for c in unicodedata.normalize('NFD', s)\n",
    "        if unicodedata.category(c) != 'Mn'\n",
    "    )\n",
    "\n",
    "# Lowercase, trim, and remove non-letter characters\n",
    "def normalize_string(s):\n",
    "    s = unicode_to_ascii(s.lower().strip())\n",
    "    s = re.sub(r\"([.!?])\", r\" \\1\", s)\n",
    "    s = re.sub(r\"[^a-zA-Z.!?]+\", r\" \", s)\n",
    "    return s"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "接下来我们需要读入数据，并将文本按行分开，将每行新闻文本(new)和其对应摘要(title)作为一个pair，用于后续训练。因此需要设计一个可以读取文本、整合pair的函数，我们添加了一个`reverse`字段用于逆序组合（`reverse`为`True`时一个pair中文本在前，摘要在后，即：[new,title]）。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def read_langs(lang1, lang2, reverse=False):\n",
    "    print(\"Reading lines...\")\n",
    "\n",
    "    # Read the file and split into lines\n",
    "    lines1 = open(file_path+'/%s.txt' % lang1, encoding='utf8').read().strip().split('\\n')\n",
    "    lines2 = open(file_path+'/%s.txt' % lang2, encoding='utf8').read().strip().split('\\n')\n",
    "    \n",
    "    # Split every line into pairs and normalize\n",
    "    pairs = [[normalize_string(lines1[x]), normalize_string(lines2[x])] for x in range(len(lines1))]\n",
    "    \n",
    "    # Reverse pairs, make Lang instances\n",
    "    if reverse:\n",
    "        pairs = [list(reversed(p)) for p in pairs]\n",
    "        voc = Voc(lang1+lang2)\n",
    "    else:\n",
    "        voc = Voc(lang1+lang2)\n",
    "        \n",
    "    return voc, pairs"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 筛选句子，Filtering sentences"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "考虑以下两点：\n",
    "- 该部分模型是作为合成模型的第二部分，从抽取式模型抽取的重要句子中生成式产生摘要，因此我们输入也应该尽可能短一些。\n",
    "- 数据量很大，为了先出一版结果快速迭代，也应该采用小量数据便于加快训练速度。\n",
    "\n",
    "因此我们选择的最大训练新闻文本长度为50个tokens（包括标点）。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "MAX_LENGTH = 50\n",
    "\n",
    "def filter_pair(p):\n",
    "    return len(p[0].split(' ')) < MAX_LENGTH and len(p[1].split(' ')) < MAX_LENGTH \n",
    "\n",
    "def filter_pairs(pairs):\n",
    "    return [pair for pair in pairs if filter_pair(pair)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 数据预处理步骤汇总，preprocessing pipeline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "数据预处理的pipeline如下：\n",
    "\n",
    "- Read text file and split into lines, split lines into pairs\n",
    "- Normalize text, filter by length and content\n",
    "- Make word lists from sentences in pairs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Reading lines...\n",
      "Read 3803957 sentence pairs\n",
      "Trimmed to 3749418 sentence pairs\n",
      "Indexing words...\n",
      "['india s economy will continue to grow at an percent rate in coming years but the government is worried about the sharp rise in unemployment over the past decade of the boom an official report said monday .', 'india s economy likely to sustain high growth but rising unemployment worries government']\n"
     ]
    }
   ],
   "source": [
    "def prepare_data(lang1_name, lang2_name, reverse=False):\n",
    "    voc, pairs = read_langs(lang1_name, lang2_name, reverse)\n",
    "    print(\"Read %s sentence pairs\" % len(pairs))\n",
    "    \n",
    "    pairs = filter_pairs(pairs)\n",
    "    print(\"Trimmed to %s sentence pairs\" % len(pairs))\n",
    "    \n",
    "    print(\"Indexing words...\")\n",
    "    for pair in pairs:\n",
    "        voc.index_words(pair[0])\n",
    "        voc.index_words(pair[1])\n",
    "\n",
    "    return voc, pairs\n",
    "\n",
    "voc, pairs = prepare_data('train.title', 'train.article', True)\n",
    "\n",
    "# Print an example pair\n",
    "print(random.choice(pairs))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. 映射词向量"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "为了训练seq2seq网络，我们需要把单词映射为向量。将每个句子转化为张量（Tensor），具体做法是先将句子分词，然后利用之前设计的word2index找到每个tokens对应的index，再将这些index组合起来形成Tensor。在创建Tensor时我们还需要在句子最后加上`EOS`字符代表句子结束。\n",
    "\n",
    "![](https://i.imgur.com/LzocpGH.png)\n",
    "\n",
    "Tensor是个多维度的数组，并且可以被定义为不同格式，比如LongTensor，FloatTensor等。再本项目中我们利用LongTensor来表示词向量。\n",
    "\n",
    "PyTorch模型利用变量（Variable）作为输入（而不是Plain Tensor），Variable本身是一个能记录动态流图状态的Tensor，这个特性有助于实现自动反向求导。可以去了解一下PyTorch中的autograd机制，有助于理解。autograd全称为automatic calculation of backwards gradients。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "下面我们设计三个函数来实现从tokens到tensor乃至variable的转换：`indexes_from_sentence`用来实现从句子提取单词并转化为对应的index；`variable_from_sentence`用来实现从句子生成Variable；`variables_from_pair`用来从每个pair中生成新闻文本（new）和摘要（title）的Variable，用于最终训练。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# Return a list of indexes, one for each word in the sentence\n",
    "def indexes_from_sentence(voc, sentence):\n",
    "    return [voc.word2index[word] for word in sentence.split(' ')]\n",
    "\n",
    "def variable_from_sentence(voc, sentence):\n",
    "    indexes = indexes_from_sentence(voc, sentence)\n",
    "    indexes.append(EOS_token)\n",
    "    var = Variable(torch.LongTensor(indexes).view(-1, 1))\n",
    "#     print('var =', var)\n",
    "    if USE_CUDA: var = var.cuda()\n",
    "    return var\n",
    "\n",
    "def variables_from_pair(pair):\n",
    "    input_variable = variable_from_sentence(voc, pair[0])\n",
    "    target_variable = variable_from_sentence(voc, pair[1])\n",
    "    return (input_variable, target_variable)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**注意**，我们这里只是简单的利用词表中的index来生成词向量，并没有利用Google的word2vec来生成词向量。这样做的原因是出于快速迭代的考虑，先简单实现一个版本看看效果如何。后续`3. 映射词向量`这一部分会利用word2vec来做词向量的映射。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "至此，我们的数据整理和词向量映射的部分已经结束，下一步就是利用PyTorch构建模型结构用于训练了。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. 建立模型"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "模型采用的是引入attention机制的encoder-decoder模型，这里分为几个部分介绍。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Encoder"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "seq2seq模型的encoder的输出是输入对应的一个映射，对于每个输入encoder都会生成一个向量和上一个时刻的隐层状态向量（hidden state），通过hidden layer计算生成当前时刻的隐层状态向量并作为下一个时刻的输入。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "class EncoderRNN(nn.Module):\n",
    "    def __init__(self, input_size, hidden_size, n_layers=1):\n",
    "        super(EncoderRNN, self).__init__()\n",
    "        \n",
    "        self.input_size = input_size\n",
    "        self.hidden_size = hidden_size\n",
    "        self.n_layers = n_layers\n",
    "        \n",
    "        self.embedding = nn.Embedding(input_size, hidden_size)\n",
    "        self.gru = nn.GRU(hidden_size, hidden_size, n_layers)\n",
    "        \n",
    "    def forward(self, word_inputs, hidden):\n",
    "        # Note: we run this all at once (over the whole input sequence)\n",
    "        seq_len = len(word_inputs)\n",
    "        embedded = self.embedding(word_inputs).view(seq_len, 1, -1)\n",
    "        output, hidden = self.gru(embedded, hidden)\n",
    "        return output, hidden\n",
    "\n",
    "    def init_hidden(self):\n",
    "        hidden = Variable(torch.zeros(self.n_layers, 1, self.hidden_size))\n",
    "        if USE_CUDA: hidden = hidden.cuda()\n",
    "        return hidden"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "### Attention Decoder"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "#### Interpreting the Luong et al. model(s)\n",
    "\n",
    "[Effective Approaches to Attention-based Neural Machine Translation](https://arxiv.org/abs/1508.04025) by Luong et al. describe a few more attention models that offer improvements and simplifications. They describe a few \"global attention\" models, the distinction between them being the way the attention scores are calculated.\n",
    "\n",
    "The general form of the attention calculation relies on the target (decoder) side hidden state and corresponding source (encoder) side state, normalized over all states to get values summing to 1:\n",
    "\n",
    "$$\n",
    "a_t(s) = align(h_t, \\bar h_s)  = \\dfrac{exp(score(h_t, \\bar h_s))}{\\sum_{s'} exp(score(h_t, \\bar h_{s'}))}\n",
    "$$\n",
    "\n",
    "The specific \"score\" function that compares two states is either *dot*, a simple dot product between the states; *general*, a a dot product between the decoder hidden state and a linear transform of the encoder state; or *concat*, a dot product between a new parameter $v_a$ and a linear transform of the states concatenated together.\n",
    "\n",
    "$$\n",
    "score(h_t, \\bar h_s) =\n",
    "\\begin{cases}\n",
    "h_t ^\\top \\bar h_s & dot \\\\\n",
    "h_t ^\\top \\textbf{W}_a \\bar h_s & general \\\\\n",
    "v_a ^\\top \\textbf{W}_a [ h_t ; \\bar h_s ] & concat\n",
    "\\end{cases}\n",
    "$$\n",
    "\n",
    "The modular definition of these scoring functions gives us an opportunity to build specific attention module that can switch between the different score methods. The input to this module is always the hidden state (of the decoder RNN) and set of encoder outputs."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "根据Luong等人提出的attention model，我们有几种计算attention score的方式，我们先新建一个`Attn`类来实现对不同attention score计算方式的选择。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "class Attn(nn.Module):\n",
    "    def __init__(self, method, hidden_size):\n",
    "        super().__init__()\n",
    "        \n",
    "        self.method = method\n",
    "        self.hidden_size = hidden_size\n",
    "        \n",
    "        if method == 'general':\n",
    "            self.attn = nn.Linear(hidden_size, hidden_size)\n",
    "        elif method == 'concat':\n",
    "            self.attn = nn.Linear(hidden_size*2, hidden_size)\n",
    "            self.other = nn.Parameter(torch.FloatTensor(hidden_size))\n",
    "    \n",
    "    def forward(self, hidden, encoder_outputs):\n",
    "        seq_len = len(encoder_outputs)\n",
    "        attn_energies = Variable(torch.zeros(seq_len)).cuda()\n",
    "        for i in range(seq_len):\n",
    "            attn_energies[i] = self.score(hidden, encoder_outputs[i])\n",
    "        return F.softmax(attn_energies).unsqueeze(0).unsqueeze(0)\n",
    "    \n",
    "    def score(self, hidden, encoder_output):\n",
    "        if self.method == 'dot':\n",
    "            return hidden.squeeze().dot(encoder_output.squeeze())\n",
    "        if self.method == 'general':\n",
    "            energy = self.attn(encoder_output)\n",
    "            energy = hidden.squeeze().dot(energy.squeeze())\n",
    "            return  energy\n",
    "        if self.method == 'concat':\n",
    "            energy = self.attn(torch.cat(hidden, encoder_output), 1)\n",
    "            energy = self.other.dot(energy.squeeze())\n",
    "            return energy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "有了`Attn`类后，我们就可以将`Attn`机制结合近RNN的计算中，用于计算attention weights和相应的context vector。我们利用`AttnDecoderRNN`来实现这一功能。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "class AttnDecoderRNN(nn.Module):\n",
    "    def __init__(self, attn_mode, hidden_size, output_size, n_layers=1, dropout=0.1):\n",
    "        super().__init__()\n",
    "        # Parameters\n",
    "        self.attn_mode = attn_mode\n",
    "        self.hidden_size = hidden_size\n",
    "        self.output_size = output_size\n",
    "        self.n_layers = n_layers\n",
    "        self.dropout = dropout\n",
    "        \n",
    "        # Layers\n",
    "        self.embedding = nn.Embedding(output_size, hidden_size)\n",
    "        self.gru = nn.GRU(hidden_size * 2, hidden_size, n_layers, dropout=dropout)\n",
    "        self.out = nn.Linear(hidden_size * 2, output_size)\n",
    "        \n",
    "        #Attn mode\n",
    "        if attn_mode != None:\n",
    "            self.attn = Attn(attn_mode, hidden_size)\n",
    "            \n",
    "    def forward(self, word_input, last_hidden, last_context, encoder_outputs):\n",
    "        word_embeded = self.embedding(word_input).view(1, 1, -1)\n",
    "        \n",
    "        rnn_input = torch.cat((word_embeded, last_context.unsqueeze(0)), 2)\n",
    "        rnn_output, hidden = self.gru(rnn_input, last_hidden)\n",
    "        \n",
    "        attn_weight = self.attn(rnn_output.squeeze(0), encoder_outputs)\n",
    "        context = attn_weight.bmm(encoder_outputs.transpose(0, 1))\n",
    "        \n",
    "        rnn_output = rnn_output.squeeze(0)\n",
    "        context = context.squeeze(1)\n",
    "        output = F.log_softmax(self.out(torch.cat((rnn_output, context), 1)))\n",
    "        return output, context, hidden, attn_weight"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 测试模型\n",
    "\n",
    "GPU模式下，训练之前的单元测试，保证之前的代码work"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "EncoderRNN (\n",
      "  (embedding): Embedding(10, 10)\n",
      "  (gru): GRU(10, 10, num_layers=2)\n",
      ")\n",
      "AttnDecoderRNN (\n",
      "  (embedding): Embedding(10, 10)\n",
      "  (gru): GRU(20, 10, num_layers=2, dropout=0.1)\n",
      "  (out): Linear (20 -> 10)\n",
      "  (attn): Attn (\n",
      "    (attn): Linear (10 -> 10)\n",
      "  )\n",
      ")\n",
      "torch.Size([1, 10]) torch.Size([2, 1, 10]) torch.Size([1, 1, 3])\n",
      "torch.Size([1, 10]) torch.Size([2, 1, 10]) torch.Size([1, 1, 3])\n",
      "torch.Size([1, 10]) torch.Size([2, 1, 10]) torch.Size([1, 1, 3])\n"
     ]
    }
   ],
   "source": [
    "encoder_test = EncoderRNN(10, 10, 2).cuda()\n",
    "decoder_test = AttnDecoderRNN('general', 10, 10, 2).cuda()\n",
    "print(encoder_test)\n",
    "print(decoder_test)\n",
    "\n",
    "encoder_hidden = encoder_test.init_hidden()\n",
    "word_input =  Variable(torch.LongTensor([1, 2, 3])).cuda()\n",
    "encoder_outputs, encoder_hidden = encoder_test(word_input, encoder_hidden)\n",
    "\n",
    "decoder_attns = torch.zeros(1, 3, 3)\n",
    "decoder_hidden = encoder_hidden\n",
    "decoder_context = Variable(torch.zeros(1, decoder_test.hidden_size)).cuda()\n",
    "\n",
    "for i in range(3):\n",
    "    decoder_output, decoder_context, decoder_hidden, decoder_attn = decoder_test(word_input[i], decoder_hidden,\n",
    "                                                                               decoder_context, encoder_outputs)\n",
    "    print(decoder_output.size(), decoder_hidden.size(), decoder_attn.size())\n",
    "    decoder_attns[0, i] = decoder_attn.squeeze(0).cpu().data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. 训练模型"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "teacher_forcing_ratio = 0.5\n",
    "clip = 5.0\n",
    "\n",
    "def train(input_variable, target_variable, encoder, decoder, encoder_optimizer, decoder_optimizer, criterion, max_length=MAX_LENGTH):\n",
    "\n",
    "    # Zero gradients of both optimizers\n",
    "    encoder_optimizer.zero_grad()\n",
    "    decoder_optimizer.zero_grad()\n",
    "    loss = 0 # Added onto for each word\n",
    "\n",
    "    # Get size of input and target sentences\n",
    "    input_length = input_variable.size()[0]\n",
    "    target_length = target_variable.size()[0]\n",
    "\n",
    "    # Run words through encoder\n",
    "    encoder_hidden = encoder.init_hidden()\n",
    "    encoder_outputs, encoder_hidden = encoder(input_variable, encoder_hidden)\n",
    "    \n",
    "    # Prepare input and output variables\n",
    "    decoder_input = Variable(torch.LongTensor([[SOS_token]]))\n",
    "    decoder_context = Variable(torch.zeros(1, decoder.hidden_size))\n",
    "    decoder_hidden = encoder_hidden # Use last hidden state from encoder to start decoder\n",
    "    if USE_CUDA:\n",
    "        decoder_input = decoder_input.cuda()\n",
    "        decoder_context = decoder_context.cuda()\n",
    "\n",
    "    # Choose whether to use teacher forcing\n",
    "    use_teacher_forcing = random.random() < teacher_forcing_ratio\n",
    "    if use_teacher_forcing:\n",
    "        \n",
    "        # Teacher forcing: Use the ground-truth target as the next input\n",
    "        for di in range(target_length):\n",
    "            decoder_output, decoder_context, decoder_hidden, decoder_attention = decoder(decoder_input, decoder_hidden, decoder_context, encoder_outputs)\n",
    "            loss += criterion(decoder_output, target_variable[di])\n",
    "            decoder_input = target_variable[di] # Next target is next input\n",
    "\n",
    "    else:\n",
    "        # Without teacher forcing: use network's own prediction as the next input\n",
    "        for di in range(target_length):\n",
    "            decoder_output, decoder_context, decoder_hidden, decoder_attention = decoder(decoder_input, decoder_hidden, decoder_context, encoder_outputs)\n",
    "            loss += criterion(decoder_output, target_variable[di])\n",
    "            \n",
    "            # Get most likely word index (highest value) from output\n",
    "            topv, topi = decoder_output.data.topk(1)\n",
    "            ni = topi[0][0]\n",
    "            \n",
    "            decoder_input = Variable(torch.LongTensor([[ni]])) # Chosen word is next input\n",
    "            if USE_CUDA: decoder_input = decoder_input.cuda()\n",
    "\n",
    "            # Stop at end of sentence (not necessary when using known targets)\n",
    "            if ni == EOS_token: break\n",
    "\n",
    "    # Backpropagation\n",
    "    loss.backward()\n",
    "    torch.nn.utils.clip_grad_norm(encoder.parameters(), clip)\n",
    "    torch.nn.utils.clip_grad_norm(decoder.parameters(), clip)\n",
    "    encoder_optimizer.step()\n",
    "    decoder_optimizer.step()\n",
    "    \n",
    "    return loss.data[0] / target_length"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def as_minutes(s):\n",
    "    m = math.floor(s / 60)\n",
    "    s -= m * 60\n",
    "    return '%dm %ds' % (m, s)\n",
    "\n",
    "def time_since(since, percent):\n",
    "    now = time.time()\n",
    "    s = now - since\n",
    "    es = s / (percent)\n",
    "    rs = es - s\n",
    "    return '%s (- %s)' % (as_minutes(s), as_minutes(rs))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 训练参数"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "attn_model = 'general'\n",
    "hidden_size = 500\n",
    "n_layers = 2\n",
    "dropout_p = 0.05\n",
    "\n",
    "# Initialize models\n",
    "encoder = EncoderRNN(voc.n_words, hidden_size, n_layers)\n",
    "decoder = AttnDecoderRNN(attn_model, hidden_size, voc.n_words, n_layers, dropout=dropout_p)\n",
    "\n",
    "# Move models to GPU\n",
    "if USE_CUDA:\n",
    "    encoder.cuda()\n",
    "    decoder.cuda()\n",
    "\n",
    "# Initialize optimizers and criterion\n",
    "learning_rate = 0.0001\n",
    "encoder_optimizer = optim.Adam(encoder.parameters(), lr=learning_rate)\n",
    "decoder_optimizer = optim.Adam(decoder.parameters(), lr=learning_rate)\n",
    "criterion = nn.NLLLoss()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# Configuring training\n",
    "n_epochs = 5000\n",
    "plot_every = 20\n",
    "print_every = 100\n",
    "\n",
    "# Keep track of time elapsed and running averages\n",
    "start = time.time()\n",
    "plot_losses = []\n",
    "print_loss_total = 0 # Reset every print_every\n",
    "plot_loss_total = 0 # Reset every plot_every"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### let's rock and roll"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1m 32s (- 75m 50s) (100 2%) 6.8014\n",
      "1m 59s (- 47m 54s) (200 4%) 6.3355\n",
      "2m 28s (- 38m 38s) (300 6%) 6.7437\n",
      "2m 57s (- 33m 56s) (400 8%) 7.0656\n",
      "3m 30s (- 31m 32s) (500 10%) 7.3752\n",
      "4m 0s (- 29m 26s) (600 12%) 6.9194\n",
      "4m 31s (- 27m 49s) (700 14%) 6.8330\n",
      "5m 2s (- 26m 30s) (800 16%) 6.9392\n",
      "5m 34s (- 25m 25s) (900 18%) 7.1335\n",
      "6m 6s (- 24m 25s) (1000 20%) 7.0122\n",
      "6m 30s (- 23m 5s) (1100 22%) 6.4654\n",
      "6m 53s (- 21m 50s) (1200 24%) 6.7949\n",
      "7m 15s (- 20m 38s) (1300 26%) 6.7883\n",
      "7m 36s (- 19m 33s) (1400 28%) 6.5448\n",
      "7m 59s (- 18m 38s) (1500 30%) 7.0451\n",
      "8m 21s (- 17m 46s) (1600 32%) 6.9646\n",
      "8m 43s (- 16m 56s) (1700 34%) 6.6098\n",
      "9m 6s (- 16m 11s) (1800 36%) 6.4907\n",
      "9m 27s (- 15m 25s) (1900 38%) 6.3540\n",
      "9m 50s (- 14m 46s) (2000 40%) 6.8652\n",
      "10m 14s (- 14m 8s) (2100 42%) 6.7396\n",
      "10m 37s (- 13m 31s) (2200 44%) 6.9873\n",
      "11m 0s (- 12m 55s) (2300 46%) 6.7732\n",
      "11m 22s (- 12m 19s) (2400 48%) 6.7640\n",
      "11m 46s (- 11m 46s) (2500 50%) 6.7424\n",
      "12m 10s (- 11m 13s) (2600 52%) 6.9917\n",
      "12m 31s (- 10m 40s) (2700 54%) 6.4561\n",
      "12m 54s (- 10m 8s) (2800 56%) 6.5282\n",
      "13m 16s (- 9m 37s) (2900 57%) 6.3366\n",
      "13m 39s (- 9m 6s) (3000 60%) 6.5312\n",
      "14m 1s (- 8m 35s) (3100 62%) 6.4770\n",
      "14m 23s (- 8m 5s) (3200 64%) 6.2668\n",
      "14m 46s (- 7m 36s) (3300 66%) 6.8100\n",
      "15m 10s (- 7m 8s) (3400 68%) 6.7403\n",
      "15m 33s (- 6m 39s) (3500 70%) 6.6412\n",
      "15m 54s (- 6m 11s) (3600 72%) 6.2792\n",
      "16m 17s (- 5m 43s) (3700 74%) 6.4133\n",
      "16m 40s (- 5m 15s) (3800 76%) 6.9629\n",
      "17m 4s (- 4m 48s) (3900 78%) 6.3803\n",
      "17m 27s (- 4m 21s) (4000 80%) 6.5806\n",
      "17m 49s (- 3m 54s) (4100 82%) 6.5786\n",
      "18m 12s (- 3m 28s) (4200 84%) 6.6994\n",
      "18m 35s (- 3m 1s) (4300 86%) 6.6469\n",
      "18m 58s (- 2m 35s) (4400 88%) 6.5845\n",
      "19m 20s (- 2m 8s) (4500 90%) 6.3661\n",
      "19m 43s (- 1m 42s) (4600 92%) 6.3631\n",
      "20m 6s (- 1m 17s) (4700 94%) 6.1516\n",
      "20m 30s (- 0m 51s) (4800 96%) 6.5764\n",
      "20m 55s (- 0m 25s) (4900 98%) 6.8254\n",
      "21m 19s (- 0m 0s) (5000 100%) 6.6557\n"
     ]
    }
   ],
   "source": [
    "# Begin!\n",
    "for epoch in range(1, n_epochs + 1):\n",
    "    \n",
    "    # Get training data for this cycle\n",
    "    training_pair = variables_from_pair(random.choice(pairs))\n",
    "    input_variable = training_pair[0]\n",
    "    target_variable = training_pair[1]\n",
    "\n",
    "    # Run the train function\n",
    "    loss = train(input_variable, target_variable, encoder, decoder, encoder_optimizer, decoder_optimizer, criterion)\n",
    "\n",
    "    # Keep track of loss\n",
    "    print_loss_total += loss\n",
    "    plot_loss_total += loss\n",
    "\n",
    "    if epoch == 0: continue\n",
    "\n",
    "    if epoch % print_every == 0:\n",
    "        print_loss_avg = print_loss_total / print_every\n",
    "        print_loss_total = 0\n",
    "        print_summary = '%s (%d %d%%) %.4f' % (time_since(start, epoch / n_epochs), epoch, epoch / n_epochs * 100, print_loss_avg)\n",
    "        print(print_summary)\n",
    "\n",
    "    if epoch % plot_every == 0:\n",
    "        plot_loss_avg = plot_loss_total / plot_every\n",
    "        plot_losses.append(plot_loss_avg)\n",
    "        plot_loss_total = 0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Train loss"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7f327163cf98>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7f32842ff198>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.ticker as ticker\n",
    "import numpy as np\n",
    "%matplotlib inline\n",
    "\n",
    "def show_plot(points):\n",
    "    plt.figure()\n",
    "    fig, ax = plt.subplots()\n",
    "    loc = ticker.MultipleLocator(base=0.2) # put ticks at regular intervals\n",
    "    ax.yaxis.set_major_locator(loc)\n",
    "    plt.plot(points)\n",
    "\n",
    "show_plot(plot_losses)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. 评价模型效果"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "评价模型效果，即evaluating model，过程和训练模型几乎一致，但是没有target headling供我们训练。我们需要循环把decoder的输出作为下一步decoder的输入，每次decoder生成一个单词（词向量）后，我们就把他加入到输出序列中，直到decoder生成 EOS token 后我们就停止输出。我们把每一步的attention weight都保存了下来，用于最后可视化。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def evaluate(sentence, max_length=200):\n",
    "    input_variable = variable_from_sentence(voc, sentence)\n",
    "    input_length = input_variable.size()[0]\n",
    "    \n",
    "    # Run through encoder\n",
    "    encoder_hidden = encoder.init_hidden()\n",
    "    encoder_outputs, encoder_hidden = encoder(input_variable, encoder_hidden)\n",
    "\n",
    "    # Create starting vectors for decoder\n",
    "    decoder_input = Variable(torch.LongTensor([[SOS_token]])) # SOS\n",
    "    decoder_context = Variable(torch.zeros(1, decoder.hidden_size))\n",
    "    if USE_CUDA:\n",
    "        decoder_input = decoder_input.cuda()\n",
    "        decoder_context = decoder_context.cuda()\n",
    "\n",
    "    decoder_hidden = encoder_hidden\n",
    "    \n",
    "    decoded_words = []\n",
    "    decoder_attentions = torch.zeros(max_length, max_length)\n",
    "    \n",
    "    # Run through decoder\n",
    "    for di in range(max_length):\n",
    "        decoder_output, decoder_context, decoder_hidden, decoder_attention = decoder(decoder_input, decoder_hidden, decoder_context, encoder_outputs)\n",
    "        decoder_attentions[di,:decoder_attention.size(2)] += decoder_attention.squeeze(0).squeeze(0).cpu().data\n",
    "\n",
    "        # Choose top word from output\n",
    "        topv, topi = decoder_output.data.topk(1)\n",
    "        ni = topi[0][0]\n",
    "        if ni == EOS_token:\n",
    "            decoded_words.append('<EOS>')\n",
    "            break\n",
    "        else:\n",
    "            decoded_words.append(voc.index2word[ni])\n",
    "            \n",
    "        # Next input is chosen word\n",
    "        decoder_input = Variable(torch.LongTensor([[ni]]))\n",
    "        if USE_CUDA: decoder_input = decoder_input.cuda()\n",
    "    \n",
    "    return decoded_words, decoder_attentions[:di+1, :len(encoder_outputs)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "设计一个随机评价模型的函数："
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def evaluate_randomly():\n",
    "    pair = random.choice(pairs)\n",
    "    \n",
    "    output_words, decoder_attn = evaluate(pair[0])\n",
    "    output_sentence = ' '.join(output_words)\n",
    "    \n",
    "    print('>', pair[0])\n",
    "    print('=', pair[1])\n",
    "    print('<', output_sentence)\n",
    "    print('')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "> indonesian president abdurrahman wahid tuesday opened the g summit here with a brief speech and then asked vice president megawati soekarnoputri to read a written statement which she refused .\n",
      "= indonesian president opens g summit\n",
      "< u .s to to to in <EOS>\n",
      "\n"
     ]
    }
   ],
   "source": [
    "evaluate_randomly()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. 可视化attention weights"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.image.AxesImage at 0x7f32828ab0b8>"
      ]
     },
     "execution_count": 85,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\ngchjAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7f3281954e10>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "output_words, attentions = evaluate(\"house speaker newt gingrich who orchestrated the republican revolution of recent years and is overseeing the impeachment inquiry into president clinton was driven from office friday by a party that swiftly turned on him after its unexpected losses in tuesday s midterm elections .\")\n",
    "plt.matshow(attentions.numpy())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def show_attention(input_sentence, output_words, attentions):\n",
    "    # Set up figure with colorbar\n",
    "    fig = plt.figure()\n",
    "    ax = fig.add_subplot(111)\n",
    "    cax = ax.matshow(attentions.numpy(), cmap='bone')\n",
    "    fig.colorbar(cax)\n",
    "\n",
    "    # Set up axes\n",
    "    ax.set_xticklabels([''] + input_sentence.split(' ') + ['<EOS>'], rotation=90)\n",
    "    ax.set_yticklabels([''] + output_words)\n",
    "\n",
    "    # Show label at every tick\n",
    "    ax.xaxis.set_major_locator(ticker.MultipleLocator(1))\n",
    "    ax.yaxis.set_major_locator(ticker.MultipleLocator(1))\n",
    "\n",
    "    plt.show()\n",
    "    plt.close()\n",
    "\n",
    "def evaluate_and_show_attention(input_sentence):\n",
    "    output_words, attentions = evaluate(input_sentence)\n",
    "    print('input =', input_sentence)\n",
    "    print('output =', ' '.join(output_words))\n",
    "    show_attention(input_sentence, output_words, attentions)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "input = a south korean lawmaker said friday communist north korea could be producing plutonium and could have more secret underground nuclear facilities than already feared .\n",
      "output = u .s to to in in <EOS>\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x7f32828ab630>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "evaluate_and_show_attention(\"a south korean lawmaker said friday communist north korea could be producing plutonium and could have more secret underground nuclear facilities than already feared .\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 引用"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "[].http://arxiv.org/abs/1409.3215)\n",
    "\n",
    "[].https://arxiv.org/pdf/1406.1078v3.pdf\n",
    "\n",
    "[].https://arxiv.org/abs/1409.047\n",
    "\n",
    "[1]. http://forum.opennmt.net/t/text-summarization-on-gigaword-and-rouge-scoring/85\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:deeplearning]",
   "language": "python",
   "name": "conda-env-deeplearning-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
